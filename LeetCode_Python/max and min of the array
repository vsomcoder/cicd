Explanation: gfg 
solution: in any compiler

code:

"""
list can reverse with - i.e -1 last elemen 
sort takes o(n logn)
"""
class Main:
  def max_min(self, l: list[int]) -> dict:
        l.sort() 
        min_max = {"min": l[0], "max": l[-1]} 
        return min_max
      
# Create an instance of the class
m = Main()

# Get user input as a string
user_input = input("Enter numbers separated by spaces: ")
# Split the input string into individual elements
input_list = user_input.split()
# Convert the elements to integers
integer_list = [int(item) for item in input_list]

# Call the max_min method and capture the result
result = m.max_min(integer_list)

# Print the result
print(result)


time-complexity:  For any comparison-based sorting algorithm, the minimum number of comparisons required to sort an array of n elements is O(n log n)
The space complexity is O(1), as we are not using any extra space.
